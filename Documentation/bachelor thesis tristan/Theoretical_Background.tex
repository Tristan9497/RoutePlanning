\chapter{Theoretical Background}
\label{theoretical_background}
This chapter will cover the needed theoretical background about the Gazebo Simulation, the Sensor Plugins, ROS and all of the used ROS packages.

\section{ROS}
ROS (Robot Operating System) is an open Source project developed by the ``Open Source Robotics Foundation''. Like the name suggests it is an entire Operating System for Robots including Hardware abstraction, low-level device control, implementation of commonly used functionality, communication between processes and package management.\\
Furthermore it provides tools and libraries to write, build and run code across multiple computers\cite{rosintro}.\\
\subsection{Packages}
This is the main structure for software in ROS. A package can contain many different Nodes, libraries, service etc.. Furthermore it is the smallest possible Structure that can be build by ROS\cite{rosconcepts}.
\subsection{Nodes}
Nodes are processes that perform computation. Since ROS is very fine granular, a system, that controls an entire robot can contain many nodes that are connected using topics. A package can be written with the use of one of the client libraries roscpp or rospy\cite{rosconcepts}.
\subsection{Plugins}
\subsection{Topics and service}
All of the ROS Nodes are connected with a publisher/subscriber like structure. The topic is basically just a name for a certain message.\\

Not only one node but unlimited many nodes can publish and subscribe to one topic. This generally can be seen like a message bus with not limited connection permissions\cite{rosconcepts}.

Unfortunately the Topic system is not well fitted for request and answers between two nodes, therefore the service structure has been implemented.\\ 
A node might offers a service under a certain node and an other node can call that service. Services can have any in- and output that can be specified in a ``.srv'' file\cite{rosconcepts}.

\subsection{RVIZ}
rviz is a 3D visualization tool offered by default in ROS. It offers functionality to visualize sensor and further geometric data.\\
\subsection{REP}
REP's (short for ROS enhanced proposals) are guidelines made and maintained by the ros community. It is highly advisable to follow the guidelines as much as possible.

Complying to these guidelines allows external people easier comprehension of the structure of the robot and eliminates misunderstandings.

The most important REP's in this project are REP 103 and REP 105.
\subsubsection{REP 103}
	
	"This REP provides a reference for the units and coordinate conventions used within ROS"\cite{REP103}\\  
	
	\textbf{Coordinate Frame}
	\begin{itemize}
		\item \textbf{X-Axis} - Forward
		\item \textbf{Y-Axis} - Left
		\item \textbf{Z-Axis} - Up
	\end{itemize}
	
	\textbf{Units}\\
	Units will always be represented in SI Units and their derived units.\\
	
	\textbf{The order of preference for rotations}
	\begin{enumerate}
		\item Quaternion
		\item Rotation matrix
		\item fixed axis roll, pitch, yaw
		\item Euler angles
	\end{enumerate}
	\cite{REP103}
	
\subsubsection{REP 105}
	"This REP specifies naming conventions and semantic meaning for coordinate frames of mobile platforms used with ROS."\cite{REP105}\\
	
	REP103 Applies for all fixed coordinate frames.
	
	\textbf{Coordinate Frames}
	\begin{itemize}
		\item \textbf{base\_link} is a fixed frame on the robot base. It serves as the reference points for all of hardware mounted on the robot itself like sensors.
		\item \textbf{odom} is a world fixed frame that serves as the reference for the pose of the robot.\\ Since the pose of the robot will drift over time it wont serve as a good long term reference.\\In most cases the odom frame will be computed using localization sensors like wheel odometry, imu's, visual odometry, etc. which leads to a continuous frame.
		\item \textbf{map} is a world fixed coordinate frame that serves as the reference for the odometry frame. It is also the base for a map of the environment such as the ones provided by slam algorithms. The frame is time discrete since it is mostly computed by localization algorithms.
	\end{itemize}
	
	That tree can be extended by an earth frame that would be the reference for the localization of the map in the earth. Which is useful, for long range robot platforms.\cite{REP105}
	
	
	
\subsection{TF}
In most cases robots that are controlled by ros have a so called tf\_tree. This tree is the coordinate frame structure of the robot. In it every sensor and actor has its own coordinate frame.\\
 The structure in most trees of mobile platforms is quite similar which is caused by the REP105 (ROS Enhanced Proposals) this contains a definition of recommended names for the robot frames and their order in the tree. But it should be noted that not every frame that is defined in the norm has to be in every tree. The basic structure mostly starts at a so called fixed frame. This Frame will be the not changing frame in the environment. At moving robots this is often earth, map or odom, while in stationary robots this can even be base\_link.\\
 

The tree is normally build up like in the following image. 

TF2 is the successor of TF and is a very powerful tool in the ROS environment. With it it is possible to transform sensor\_msgs and geometry\_msgs from one frame in another. Furthermore it offers the possibility to transform old data into the present or at any other point in the past.

\subsubsection{URDF and xacro}
The robot hardware description consists of one or more URDF(Unified Robot Description Format) based xml file. Its purpose is to define the shape and geometric of every part of the robot. 

\subsubsection{robot\_state\_publisher}
	This package uses the robot hardware description and builds up the tf\_tree using static\_transform\_publishers.

\section{Gazebo}


\subsection{Plugins}
Gazebo offers a wide selection of pre made plugins that can be incorporated into a simulated robot by attaching the plugin to the right tf\_frame and configuring its parameters.

\subsection{Models}


\section{navigation stack}
\subsection{move\_base}
\subsection{global\_planner}
\subsubsection{base\_global\_planner}
This is the default global planner of move\_base .
\subsection{local\_planner}
\subsubsection{teb\_local\_planner}

\subsubsection{dwa\_local\_planner}
\subsection{costmap}
A costmap is a grid stile map, whose purpose is to store information about obstacles in the surrounding of the robot.\\
There are two different costmaps, the global costmap and the local costmap.
The global costmap is by the global planner to find a collision free path. Whereas the local costmap is used by the local planner for local planning.\cite{navsetup}\\
\begin{figure}[H]
	\includegraphics[width=\textwidth]{Pictures/costmap_rviz}
	\caption{costmap with obstacles and inflation \cite{costmap}}
	\label{costmap}
\end{figure}


\subsubsection{Cost Values}
The values in a costmap can be in the range [0-255], but the underlying structure categorizes them in the following 3 sections:
\begin{itemize}
	\item lethal obstacle
	\item free space
	\item no information
\end{itemize}

\subsection{marking and clearing}
Obstacles in the costmap can not only be marked, but also cleared by the subscribed data source. For each data source a configuration regarding the clearing and marking permissions is necessary. For clearing the costmap uses a raytracing algorithm, which allows the costmap to handle moving obstacles\cite{costmap}.
\subsubsection{Inflation}
Inflation is a process where a occupied cell is inflated by over the distance decreasing cost values for a configurable radius, as pictured in Figure \ref{costmap}.\\
This process is used by the default plugin inflation\_layer with the cost distribution pictured in Figure \ref{costdistribution}\cite{costmap}.

\begin{figure}[H]
	\includegraphics[width=\linewidth]{Pictures/costmapinflation}
	\caption{cost distribution and classification \cite{costmap}}
	\label{costdistribution}
\end{figure}

The usage of inflation has two reasons. First it is used to close gaps between two measured obstacles and therefore usefull, if the sensor resolution is relatively corse.\\
The second reason is to prevent the planner from getting too close to obstacles. Therefore the inflation radius is typically set to slightly more than the radius of the robot\cite{costmap}.

\subsubsection{layer}
The costmap uses a layer structure of plugins that can handle different tasks. The costmap then combines the data from each layer, to produce the final costmap.\\

By default the costmap\_2d package offers the following 3 layers:
\begin{itemize}
	\item \textbf{static map layer} is a layer that converts a prerecorded map into obstacles.
	\item  \textbf{obstacle layer} is a plugin that handles input from sensor sources. The plugin marks and raytraces obstacles in 2D. It can handle LaserScans PointCloud and PointCloud2.
	\item \textbf{inflation layer} handles the inflation of lethal obstacles in the costmap.
\end{itemize}

Furthermore the plugins Social ``Costmap Layer'' and ``Range Sensor Layer'' are offered.

Using the pluginlib interface and the costmap libraries one can develop custom layers for the costmap to achieve special behaviour of the robot.



\section{cartographer}
Cartographer is a Lidar based SLAM developed by Google. In contrast to gmapping it is based on loop closure to ensure real time mapping even in relatively big environments.\\
Submaps are considered for loop closure, if they are close to each other. A scan matcher tries to find constraints between the submaps and the current scan. When searching for loop closure constraints at a certain rate one can achieve basically instantaneous optimization of the map just by the fact that the current scan is similar to one of the underlying submaps\cite{cartographer}.\\

\section{Carolo-Cup}
The carolo cup is an event hosted by University Braunschweig and is an event in which the teams of many different universities can compete against each other and present their work and progress in the field of autonomous driving.

There are two different levels of difficulty the carolo basic cup and the carolo master cup.













